Instalamos la librería de manera global

npm install -g create-react-app


Creamos nuestro proyecto:

create-react-app places


## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.<br>
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br>
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.<br>
See the section about [running tests](#running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.<br>
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

See the section about [deployment](#deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.



Conectamos proyecto con GitHub

echo "# Basic-React" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/JFCasas/Basic-React.git
git push -u origin master



JSX

Si examinamos el fichero App.js vemos el primer ejemplo de JSX


<h1 className="App-title">Welcome to React</h1>

Utilizamos className para especificar clases en vez de la palabra reservada de Javascript "class"


 Podemos colocar expresiones Javascript mediante la utilización de {}

 Un ejemplo puede ser el siguiente:

 <header className="App-header">
  <img src={logo} className="App-logo" alt="logo" />
  <h1 className="App-title">Welcome to React</h1>
  {20*10}
</header>


Se pueden definir funciones y ejecutarlas dentro de JSX

class App extends Component {

  hello(){

    return "Hola Mundo"
  }
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Welcome to React</h1>
          
          {this.hello()}
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

Se van a poder establecer ciclos, condiciones........




PRIMER COMPONENTE

Dentro de src creamos la carpeta components

Creamos un archivo con nombre Title.js


import React from 'react'

export default class Title extends React.Component {

	render(){

		return (

			<div>
				<h1>Places</h1>
				<p>Descubre lugares de manera simple</p>
			</div>
		)
	}
}

Una vez creado nuestro componente hacemos uso del mismo:

App.js

import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

import Title from './components/Title'

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          
          <Title></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;





IMPORTAR Y EXPORTAR MÓDULOS ES6

"import" nos permite traer módulos externos para utilizarlos en nuestro desarrollo

Observamos 2 maneras de importar

import React from 'react'

import React, { Component } from 'react';


Depende de la manera de como hemos exportado. Existe como hemos visto anteriormente la posibilidad de exportar un módulo por defecto.

Supongamos que en Title.js tenemos lo siguiente;


export function hola(){
	
	return "hola"
}

En App.js

import {hola} from './components/Title'

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />

          {hola()}
          
          <Title></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;


Sólo puede haber un único elemento que se exporta por defecto con el key "default"



DATOS VIA PROPS

Props son las propiedades  de un componente que enviamos cuando el componente se genera.

Podríamos hacer algo de la siguiente manera:

Title.js

import React from 'react'

export default class Title extends React.Component {

	render(){

		return (

			<div>

				<h1>{this.props.title}</h1>
				<p>Descubre lugares de manera simple</p>
			
			</div>
		)
	}

}

App.js

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />

          <Title title="PEPEHILLO"></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;


Principal característica de los props de un componente es que son inmutables. 

Ese valor no se puede modificar. 

Para valores y datos dinámicos se utilizaran "state" de los que hablaremos posteriormente.



ENCABEZADO DEL PROYECTO

Empezamos a definir la forma de nuestro proyecto en cuestión. 

Editamos archivo App.js





ARCHIVOS ESTÁTICOS EN LA CARPETA PUBLIC

DESPLEGAR ARCHIVOS ESTÁTICOS EN NUESTRA APLICACIÓN

Nos bajamos una imagen de pexels. Vamos a integrala en nuestro proyecto

Creamos la carpeta "images" dentro de la carpeta "public"



App.js

.................

<Title></Title> 
<button>Crear Cuenta Gratuita</button>
<img src={process.env.PUBLIC_URL + '/images/places1.jpeg'} height="200"/>

.................



STATE DE UN COMPONENTE

Damos un valor por default a nuestro state. Esto lo hacemos desde el constructor.

Recibe un argumento con los props del componente. Esos props se pasan al constructor del padre, en este caso la clase "Component" utilizando el keyword "super"

Iniciamos el objeto state que guarda datos que se pueden actualizar mediante se está usando nuestro componente.

Colocamos un número que inicia en 0


La única forma en que debemos actualizar un valor que forma parte del estado es mediante la función setState. El parámetro es un JSON

Tenemos el siguiente código:

App.js

...........

class App extends Component {

  constructor(props){

    super(props)

    this.state = {

      numero: 0
    }

    setInterval(()=>{

      this.setState({

        numero: this.state.numero + 1
      
      })
    
    },1000)
  }

  render() {

  ............




EVENTOS EN COMPONENTES


Añadimos el evento al button de la siguiente manera:

<button onClick={()=>{this.updateNumero()}}  >Crear Cuenta Gratuita</button>


Creamos la función de la siguiente manera:

updateNumero(){

    this.setState({

        numero: this.state.numero + 1
      
	})
}



BIND


---------------------------------

Es un método que poseen todas las funciones en javascript

Es una solución más elegante, ya que nuestra función executor queda de la siguiente forma:

function executor(f){
	
	f()

}

var objeto = {

	nombre: "Fernando",
	apellido: "Casas",
	escribeNombre: function(){

		console.log("Tu nombre es " + this.nombre + " " +  this.apellido)
	}
}

var avion = {

	modelo: "Airbus",
	diModelo: function(){

		console.log("El modelo del avión es: " + this.modelo)
	}


}

executor(objeto.escribeNombre.bind(objeto));

executor(avion.diModelo.bind(avion));

Como vemos en el ejemplo mediante "bind" podemos determianar únivoacamente el valor de this

Aplicado a nuestro código nos permite escribirlo de una manera más elegante bastante acepatada por la comunidad en React

class App extends Component {

  constructor(props){

    super(props)

    this.state = {

      numero: 0
    }

    this.updateNumero = this.updateNumero.bind(this)

  }

  updateNumero(){

      this.setState({

        numero: this.state.numero + 1

            
      })
  }

  .....................
  .....................

  <button onClick={this.updateNumero}  >Crear Cuenta Gratuita</button>




ESTILOS

Vamos a tener dos maneras de aplica estilos.

La primera es la utilización del atributo "style"

La otra es la utilización de "className"





MATERIAL DESIGN

npm install material-ui --save

Beginning with v0.15.0, Material-UI components require a theme to be provided. The quickest way to get up and running is by using the MuiThemeProvider to inject the theme into your application context. Following that, you can use any of the components as demonstrated in our documentation.


Todos los componentes que vamos a poder usar se encuentran en la página de materia-ui


Primer componente que importamos:

import RaisedButton from 'material-ui/RaisedButton';

<RaisedButton label="Crear Cuenta Gratuita" secondary={true} onClick={this.updateNumero}  />



Colores Material Design para nuestros cpmponentes


import {indigo400} from 'material-ui/styles/colors'

<div style={{"background-color":indigo400}}>



Card

mport {Card, CardActions, CardHeader, CardText} from 'material-ui/Card';

<Card style={{"font-family":"'Roboto', sans-serif"}}>
  <CardHeader  style={{"font-weight":"bold"}}

    title="Calificaciones con emociones"
    avatar="images/experiencias.jpeg"
    
  />
  <CardActions>
    <FlatButton label="Action1" />
    <FlatButton label="Action2" />
  </CardActions>
  <CardText >

    
    Califica tus lugares con experiencias, no con números
  
  </CardText>
</Card>




MOCKING DE DATOS

Creamos una carpeta requests dentro de src

Dentro de esta carpeta creamos un archivo places.js donde creamos nuestros datos


Realizamos el import en App.js

import data from './requests/places'


Vamos a ver que tiene data haciendo un console.log en el constructor

Object
  places :
  
  Array(3)
    0
    :
    {imageUrl: "/images/place-1.jpeg", title: "Primer negocio", descripcion: "Primera descripción de mi negocio"}
    1
    :
    {imageUrl: "/images/place-2.jpeg", title: "Segundo negocio", descripcion: "Segunda descripción de mi negocio"}
    2
    :
    {imageUrl: "/images/place-3.jpeg", title: "Tercer negocio", descripcion: "Tercera descripción de mi negocio"}


Realizamos la siguiente función

places(){

    return data.places.map(place=>{

      return(

        <Card style={{"font-family":"'Roboto', sans-serif"}}>
          
          <CardMedia >

            <img className = "imagen"  src={process.env.PUBLIC_URL + place.imageUrl}  />
          
          </CardMedia>

          <CardTitle title={place.title}></CardTitle>

          <CardText >{place.description}</CardText>
        
        </Card>
      )

    })
  }

  La utilizamos:

  <div className = "places">

    {this.places()}
    

  </div> 





RESOLUCIÓN ERRORES EN CONSOLA

Si echamos un vistazo a la consola vamos a ver diferentes errores que vamosa ir subsanado.

Errores en consola.

Warning: Each child in an array or iterator should have a unique "key" prop.

Check the render method of `App`. See https://fb.me/react-warning-keys for more information.
    in Card (at App.js:51)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property font-weight. Did you mean fontWeight?
    in div (created by CardHeader)
    in CardHeader (at App.js:93)
    in div (created by Card)
    in div (created by Paper)
    in Paper (created by Card)
    in Card (at App.js:92)
    in ul (at App.js:90)
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property font-family. Did you mean fontFamily?
    in div (created by Paper)
    in Paper (created by Card)
    in Card (at App.js:92)
    in ul (at App.js:90)
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property background-color. Did you mean backgroundColor?
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property margin-top. Did you mean marginTop?
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)





COMPONENTES PÁGINA

Vamos a refactorizar nuestro código haciendo que la página "home" de nuestra aplicación sea cargado como un componente.


Creamos la carpeta pages

Dentro de esta carpeta creamos el archivo Home.js

Tenemos que importarlo de la siguiente manera:

import Home from './pages/Home'

Llevamos a Home.js todo el código que estaba antes en App.js





CREACION COMPONENTE PARA LOS DISTINTOS NEGOCIOS

Refactorizamos nuestro código. 

Podríamos realizar un componente para los beneficios. No considero importante realizarlo ya que este componente no lo vamos a utilizar en otras partes de nuestro código.


Vamos a realizar un componente para los negocios:

PlaceCard


Home.js

...................

places(){

  return data.places.map((place,index)=>{

    return(

      <PlaceCard place={place} index={index}></PlaceCard>
    )

  })
}

PlaceCard.js

import React from 'react'

import {Card, CardActions, CardHeader, CardText, CardMedia, CardTitle} from 'material-ui/Card';

export default class PlaceCard extends React.Component {

  render(){

    return (

      <Card style={{"fontFamily":"'Roboto', sans-serif"}} key={this.props.index}>
            
            <CardMedia >

              <img className = "imagen"  src={process.env.PUBLIC_URL + this.props.place.imageUrl}  />
            
            </CardMedia>

            <CardTitle title={this.props.place.title}></CardTitle>

            <CardText >{this.props.place.description}</CardText>
          
          </Card>
      )
  }

}




ACTUALIZAR LA VISTA. OCULTACION DE NEGOCIOS

Incorporamos dos botones a cada uno de los negocios

<CardActions style={{"textAlign": "right"}}>
  <FlatButton label="Ver mas....." secondary={true}/>
  <FlatButton label="Ocultar" secondary={true}/>
</CardActions>


Cuando demos en ocultar tiene que desaparecer la tarjeta.

Vamos a manipular el arreglo places


Tenemos que enviar una funcion desde el padre al hijo. Lo podemos hacer de nuevo utilzando props


Mandamos una función onRemove que es hidePlace

places(){

      return this.state.places.map((place,index)=>{

        return(

          <PlaceCard place={place} index={index} onRemove={this.hidePlace}></PlaceCard>
        )

      })
  }

  hidePlace(place){

    this.setState({

      places : this.state.places.filter(el => el != place)

    })
  }


Cuando ejecutemos hidePlace desde el componente PlaceCard un efecto colateral es que this va a ser reasignado

Una manera de evitar esto es medianste bind

this.hidePlace = this.hidePlace.bind(this)


Finalmente en nuestro componente:

<CardActions style={{"textAlign": "right"}}>
  <FlatButton label="Ver mas....." secondary={true}/>
  <FlatButton label="Ocultar" secondary={true} onClick={()=> this.props.onRemove(this.props.place)}   />
</CardActions>









INSTALAR Y CONFIGURAR REACT TRANSITION GROUP

https://reactcommunity.org/react-transition-group/

npm install react-transition-group --save



DEFINIR TRANSICION CSS

Llamamos a la animación fade-scale

La transicion va a durar 300 ms

Para empezar la opacidad va a estar en 0 (Totalmente transparente)

La escala en 0 (No se ve)


Definimos la animación de la siguiente manera:

App.css

.fade-scale-enter {
  opacity: 0;
  transform: scale(0);
}

.fade-scale-enter.fade-scale-enter-active {
  opacity: 1;
  transform: scale(1);
  transition: all 300ms cubic-bezier(0.25, 0.1, 0.25, 1);
}

.fade-scale-exit {
  opacity: 1;
  transform: scale(1);
}

.fade-scale-exit.fade-scale-exit-active {
  opacity: 0;
  transform: scale(0);
  transition: all 300ms cubic-bezier(0.25, 0.1, 0.25, 1);
}






CSSTransition


Vamos a llevar a cabo la animación de PlaceCard

import CSSTransition from 'react-transition-group/CSSTransition'


Lo establecemos como wraper de todo el elemento que queremos animar

<CSSTransition timeout = {300}  classNames = 'fade-scale' in = {this.state.show}  >

timeout   Indica cuanto va a durar la animación.

classNames que contiene el nombre del efecto, en nuestro caso fade-scale

También tenemos un prop in que define si esta entrando o saliendo el elemento


Hacenmos que el prop "in" sea igual al cambio de una propiedad del estado del componente

 a la cual llamamos "show"


Definimos en el constructor:

setInterval(()=>this.setState({show: !this.state.show}),1000)






ANIMAR UN GRUPO DE ELEMENTOS


Quitamos la función  setInterval

El valor de in pasa a ser el siguiente:

in = {this.props.in}. Dejamos que el componente padre lo inserte al componente hijo



Importamos TransitionGroup en el componente Home

import TransitionGroup from 'react-transition-group/TransitionGroup'


Finalmente:

<TransitionGroup className = "places">

  {this.places()}
  

</TransitionGroup> 
