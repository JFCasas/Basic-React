Instalamos la librería de manera global

npm install -g create-react-app


Creamos nuestro proyecto:

create-react-app places


## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.<br>
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br>
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.<br>
See the section about [running tests](#running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.<br>
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

See the section about [deployment](#deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.



Conectamos proyecto con GitHub

echo "# Basic-React" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/JFCasas/Basic-React.git
git push -u origin master



JSX

Si examinamos el fichero App.js vemos el primer ejemplo de JSX


<h1 className="App-title">Welcome to React</h1>

Utilizamos className para especificar clases en vez de la palabra reservada de Javascript "class"


 Podemos colocar expresiones Javascript mediante la utilización de {}

 Un ejemplo puede ser el siguiente:

 <header className="App-header">
  <img src={logo} className="App-logo" alt="logo" />
  <h1 className="App-title">Welcome to React</h1>
  {20*10}
</header>


Se pueden definir funciones y ejecutarlas dentro de JSX

class App extends Component {

  hello(){

    return "Hola Mundo"
  }
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Welcome to React</h1>
          
          {this.hello()}
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

Se van a poder establecer ciclos, condiciones........




PRIMER COMPONENTE

Dentro de src creamos la carpeta components

Creamos un archivo con nombre Title.js


import React from 'react'

export default class Title extends React.Component {

	render(){

		return (

			<div>
				<h1>Places</h1>
				<p>Descubre lugares de manera simple</p>
			</div>
		)
	}
}

Una vez creado nuestro componente hacemos uso del mismo:

App.js

import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

import Title from './components/Title'

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          
          <Title></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;





IMPORTAR Y EXPORTAR MÓDULOS ES6

"import" nos permite traer módulos externos para utilizarlos en nuestro desarrollo

Observamos 2 maneras de importar

import React from 'react'

import React, { Component } from 'react';


Depende de la manera de como hemos exportado. Existe como hemos visto anteriormente la posibilidad de exportar un módulo por defecto.

Supongamos que en Title.js tenemos lo siguiente;


export function hola(){
	
	return "hola"
}

En App.js

import {hola} from './components/Title'

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />

          {hola()}
          
          <Title></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;


Sólo puede haber un único elemento que se exporta por defecto con el key "default"



DATOS VIA PROPS

Props son las propiedades  de un componente que enviamos cuando el componente se genera.

Podríamos hacer algo de la siguiente manera:

Title.js

import React from 'react'

export default class Title extends React.Component {

	render(){

		return (

			<div>

				<h1>{this.props.title}</h1>
				<p>Descubre lugares de manera simple</p>
			
			</div>
		)
	}

}

App.js

class App extends Component {

  
  
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />

          <Title title="PEPEHILLO"></Title> 
          
        </header>

        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>


    );
  }
}

export default App;


Principal característica de los props de un componente es que son inmutables. 

Ese valor no se puede modificar. 

Para valores y datos dinámicos se utilizaran "state" de los que hablaremos posteriormente.



ENCABEZADO DEL PROYECTO

Empezamos a definir la forma de nuestro proyecto en cuestión. 

Editamos archivo App.js





ARCHIVOS ESTÁTICOS EN LA CARPETA PUBLIC

DESPLEGAR ARCHIVOS ESTÁTICOS EN NUESTRA APLICACIÓN

Nos bajamos una imagen de pexels. Vamos a integrala en nuestro proyecto

Creamos la carpeta "images" dentro de la carpeta "public"



App.js

.................

<Title></Title> 
<button>Crear Cuenta Gratuita</button>
<img src={process.env.PUBLIC_URL + '/images/places1.jpeg'} height="200"/>

.................



STATE DE UN COMPONENTE

Damos un valor por default a nuestro state. Esto lo hacemos desde el constructor.

Recibe un argumento con los props del componente. Esos props se pasan al constructor del padre, en este caso la clase "Component" utilizando el keyword "super"

Iniciamos el objeto state que guarda datos que se pueden actualizar mediante se está usando nuestro componente.

Colocamos un número que inicia en 0


La única forma en que debemos actualizar un valor que forma parte del estado es mediante la función setState. El parámetro es un JSON

Tenemos el siguiente código:

App.js

...........

class App extends Component {

  constructor(props){

    super(props)

    this.state = {

      numero: 0
    }

    setInterval(()=>{

      this.setState({

        numero: this.state.numero + 1
      
      })
    
    },1000)
  }

  render() {

  ............




EVENTOS EN COMPONENTES


Añadimos el evento al button de la siguiente manera:

<button onClick={()=>{this.updateNumero()}}  >Crear Cuenta Gratuita</button>


Creamos la función de la siguiente manera:

updateNumero(){

    this.setState({

        numero: this.state.numero + 1
      
	})
}



BIND


---------------------------------

Es un método que poseen todas las funciones en javascript

Es una solución más elegante, ya que nuestra función executor queda de la siguiente forma:

function executor(f){
	
	f()

}

var objeto = {

	nombre: "Fernando",
	apellido: "Casas",
	escribeNombre: function(){

		console.log("Tu nombre es " + this.nombre + " " +  this.apellido)
	}
}

var avion = {

	modelo: "Airbus",
	diModelo: function(){

		console.log("El modelo del avión es: " + this.modelo)
	}


}

executor(objeto.escribeNombre.bind(objeto));

executor(avion.diModelo.bind(avion));

Como vemos en el ejemplo mediante "bind" podemos determianar únivoacamente el valor de this

Aplicado a nuestro código nos permite escribirlo de una manera más elegante bastante acepatada por la comunidad en React

class App extends Component {

  constructor(props){

    super(props)

    this.state = {

      numero: 0
    }

    this.updateNumero = this.updateNumero.bind(this)

  }

  updateNumero(){

      this.setState({

        numero: this.state.numero + 1

            
      })
  }

  .....................
  .....................

  <button onClick={this.updateNumero}  >Crear Cuenta Gratuita</button>




ESTILOS

Vamos a tener dos maneras de aplica estilos.

La primera es la utilización del atributo "style"

La otra es la utilización de "className"





MATERIAL DESIGN

npm install material-ui --save

Beginning with v0.15.0, Material-UI components require a theme to be provided. The quickest way to get up and running is by using the MuiThemeProvider to inject the theme into your application context. Following that, you can use any of the components as demonstrated in our documentation.


Todos los componentes que vamos a poder usar se encuentran en la página de materia-ui


Primer componente que importamos:

import RaisedButton from 'material-ui/RaisedButton';

<RaisedButton label="Crear Cuenta Gratuita" secondary={true} onClick={this.updateNumero}  />



Colores Material Design para nuestros cpmponentes


import {indigo400} from 'material-ui/styles/colors'

<div style={{"background-color":indigo400}}>



Card

mport {Card, CardActions, CardHeader, CardText} from 'material-ui/Card';

<Card style={{"font-family":"'Roboto', sans-serif"}}>
  <CardHeader  style={{"font-weight":"bold"}}

    title="Calificaciones con emociones"
    avatar="images/experiencias.jpeg"
    
  />
  <CardActions>
    <FlatButton label="Action1" />
    <FlatButton label="Action2" />
  </CardActions>
  <CardText >

    
    Califica tus lugares con experiencias, no con números
  
  </CardText>
</Card>




MOCKING DE DATOS

Creamos una carpeta requests dentro de src

Dentro de esta carpeta creamos un archivo places.js donde creamos nuestros datos


Realizamos el import en App.js

import data from './requests/places'


Vamos a ver que tiene data haciendo un console.log en el constructor

Object
  places :
  
  Array(3)
    0
    :
    {imageUrl: "/images/place-1.jpeg", title: "Primer negocio", descripcion: "Primera descripción de mi negocio"}
    1
    :
    {imageUrl: "/images/place-2.jpeg", title: "Segundo negocio", descripcion: "Segunda descripción de mi negocio"}
    2
    :
    {imageUrl: "/images/place-3.jpeg", title: "Tercer negocio", descripcion: "Tercera descripción de mi negocio"}


Realizamos la siguiente función

places(){

    return data.places.map(place=>{

      return(

        <Card style={{"font-family":"'Roboto', sans-serif"}}>
          
          <CardMedia >

            <img className = "imagen"  src={process.env.PUBLIC_URL + place.imageUrl}  />
          
          </CardMedia>

          <CardTitle title={place.title}></CardTitle>

          <CardText >{place.description}</CardText>
        
        </Card>
      )

    })
  }

  La utilizamos:

  <div className = "places">

    {this.places()}
    

  </div> 





RESOLUCIÓN ERRORES EN CONSOLA

Si echamos un vistazo a la consola vamos a ver diferentes errores que vamosa ir subsanado.

Errores en consola.

Warning: Each child in an array or iterator should have a unique "key" prop.

Check the render method of `App`. See https://fb.me/react-warning-keys for more information.
    in Card (at App.js:51)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property font-weight. Did you mean fontWeight?
    in div (created by CardHeader)
    in CardHeader (at App.js:93)
    in div (created by Card)
    in div (created by Paper)
    in Paper (created by Card)
    in Card (at App.js:92)
    in ul (at App.js:90)
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property font-family. Did you mean fontFamily?
    in div (created by Paper)
    in Paper (created by Card)
    in Card (at App.js:92)
    in ul (at App.js:90)
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property background-color. Did you mean backgroundColor?
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)
__stack_frame_overlay_proxy_console__ @ index.js:2178
index.js:2178 Warning: Unsupported style property margin-top. Did you mean marginTop?
    in div (at App.js:88)
    in div (at App.js:77)
    in div (at App.js:75)
    in MuiThemeProvider (at App.js:73)
    in App (at index.js:7)





COMPONENTES PÁGINA

Vamos a refactorizar nuestro código haciendo que la página "home" de nuestra aplicación sea cargado como un componente.


Creamos la carpeta pages

Dentro de esta carpeta creamos el archivo Home.js

Tenemos que importarlo de la siguiente manera:

import Home from './pages/Home'

Llevamos a Home.js todo el código que estaba antes en App.js





CREACION COMPONENTE PARA LOS DISTINTOS NEGOCIOS

Refactorizamos nuestro código. 

Podríamos realizar un componente para los beneficios. No considero importante realizarlo ya que este componente no lo vamos a utilizar en otras partes de nuestro código.


Vamos a realizar un componente para los negocios:

PlaceCard


Home.js

...................

places(){

  return data.places.map((place,index)=>{

    return(

      <PlaceCard place={place} index={index}></PlaceCard>
    )

  })
}

PlaceCard.js

import React from 'react'

import {Card, CardActions, CardHeader, CardText, CardMedia, CardTitle} from 'material-ui/Card';

export default class PlaceCard extends React.Component {

  render(){

    return (

      <Card style={{"fontFamily":"'Roboto', sans-serif"}} key={this.props.index}>
            
            <CardMedia >

              <img className = "imagen"  src={process.env.PUBLIC_URL + this.props.place.imageUrl}  />
            
            </CardMedia>

            <CardTitle title={this.props.place.title}></CardTitle>

            <CardText >{this.props.place.description}</CardText>
          
          </Card>
      )
  }

}




ACTUALIZAR LA VISTA. OCULTACION DE NEGOCIOS

Incorporamos dos botones a cada uno de los negocios

<CardActions style={{"textAlign": "right"}}>
  <FlatButton label="Ver mas....." secondary={true}/>
  <FlatButton label="Ocultar" secondary={true}/>
</CardActions>


Cuando demos en ocultar tiene que desaparecer la tarjeta.

Vamos a manipular el arreglo places


Tenemos que enviar una funcion desde el padre al hijo. Lo podemos hacer de nuevo utilzando props


Mandamos una función onRemove que es hidePlace

places(){

      return this.state.places.map((place,index)=>{

        return(

          <PlaceCard place={place} index={index} onRemove={this.hidePlace}></PlaceCard>
        )

      })
  }

  hidePlace(place){

    this.setState({

      places : this.state.places.filter(el => el != place)

    })
  }


Cuando ejecutemos hidePlace desde el componente PlaceCard un efecto colateral es que this va a ser reasignado

Una manera de evitar esto es medianste bind

this.hidePlace = this.hidePlace.bind(this)


Finalmente en nuestro componente:

<CardActions style={{"textAlign": "right"}}>
  <FlatButton label="Ver mas....." secondary={true}/>
  <FlatButton label="Ocultar" secondary={true} onClick={()=> this.props.onRemove(this.props.place)}   />
</CardActions>









INSTALAR Y CONFIGURAR REACT TRANSITION GROUP

https://reactcommunity.org/react-transition-group/

npm install react-transition-group --save



DEFINIR TRANSICION CSS

Llamamos a la animación fade-scale

La transicion va a durar 300 ms

Para empezar la opacidad va a estar en 0 (Totalmente transparente)

La escala en 0 (No se ve)


Definimos la animación de la siguiente manera:

App.css

.fade-scale-enter {
  opacity: 0;
  transform: scale(0);
}

.fade-scale-enter.fade-scale-enter-active {
  opacity: 1;
  transform: scale(1);
  transition: all 300ms cubic-bezier(0.25, 0.1, 0.25, 1);
}

.fade-scale-exit {
  opacity: 1;
  transform: scale(1);
}

.fade-scale-exit.fade-scale-exit-active {
  opacity: 0;
  transform: scale(0);
  transition: all 300ms cubic-bezier(0.25, 0.1, 0.25, 1);
}






CSSTransition


Vamos a llevar a cabo la animación de PlaceCard

import CSSTransition from 'react-transition-group/CSSTransition'


Lo establecemos como wraper de todo el elemento que queremos animar

<CSSTransition timeout = {300}  classNames = 'fade-scale' in = {this.state.show}  >

timeout   Indica cuanto va a durar la animación.

classNames que contiene el nombre del efecto, en nuestro caso fade-scale

También tenemos un prop in que define si esta entrando o saliendo el elemento


Hacenmos que el prop "in" sea igual al cambio de una propiedad del estado del componente

 a la cual llamamos "show"


Definimos en el constructor:

setInterval(()=>this.setState({show: !this.state.show}),1000)






ANIMAR UN GRUPO DE ELEMENTOS


Quitamos la función  setInterval

El valor de in pasa a ser el siguiente:

in = {this.props.in}. Dejamos que el componente padre lo inserte al componente hijo



Importamos TransitionGroup en el componente Home

import TransitionGroup from 'react-transition-group/TransitionGroup'


Finalmente:

<TransitionGroup className = "places">

  {this.places()}
  

</TransitionGroup> 


NO FUNCIONA


Inserto un nuevo componente "Board"


Esta vez los elementos los inserto mediante un botón y funciona correctamente al insertarlos. Los inserta y los anima.

Falla de nuevo al eliminarlos.



Dejo el código para que funcione de manera correcta en la eliminación de los negocios





REACT ROUTER

npm install react-router-dom

Primero vamos a realizar un pequeño ejemplo y luego lo integramos en nuestra aplicación

App.js

Llevamos a cabo el import

import {

  BrowserRouter as Router,
  Link,
  Route

} from 'react-router-dom';



render() {
    
    return (

      <MuiThemeProvider>

        <Router>

          <Route exact path="/" component={Home}></Route>

          
        </Router>

        
  
      </MuiThemeProvider>
    );
}

Creamos una página "login" con un "Hola Mundo" para comprobar el correcto funcionamiento

Nos queda de la siguiente manera la parte que nos interesa:

App.js

..........

import Login from './pages/Login'

...........

render() {
    
    return (

      <MuiThemeProvider>

        <Router>

          <div>

            <Link to="/login">Login</Link>

            <Link to="/">Home</Link>

            <Route exact path="/" component={Home}></Route>
            <Route path="/login" component={Login}></Route>

          </div>

          

          
        
        </Router>

        
  
      </MuiThemeProvider>
    );
}






RUTAS Y COMPONENTES

Vamos a adopatar la siguiente solución.

Creamos el archivo Router.js



import React from 'react';

import {

  BrowserRouter as ReactRouter,
  Route

} from 'react-router-dom';

import App from './App' 

import Home from './pages/Home'
import Login from './pages/Login'

export default class Router extends React.Component {

  render(){

    return (

      <ReactRouter>

        <App>

          <Route exact path="/" component={Home}></Route>
          <Route path="/login" component={Login}></Route>

          </App>
        
      </ReactRouter>

    )
  }

}


Nuestra entrada a la aplicación es App.js. Lo podemos comprobar en el archivo index.js

Tenemos que hacer que sea Router.js

Lo hacemos de la siguiente manera:


index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import Router from './Router';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(<Router />, document.getElementById('root'));
registerServiceWorker();




BARRA DE NAVEGACIÓN

Creamos el componente  MyAppBar.js


import React from 'react';

import AppBar from 'material-ui/AppBar';

export default class MyAppBar extends React.Component {

  render(){

    return (

      <AppBar
          
          title="Places"

          style ={{"backgroundColor" : "#000" }}

          showMenuIconButton = {false}

          titleStyle ={{"color" : "#F5F5F5"}}
          
      />

    )
  }

}


App.js

...............................

import MyAppBar from './components/MyAppBar'

...............................


Ponemos nuestro nuevo componente justo encima de los componentes que decide el Router de la siguiente manera:

render() {
    
    return (

      <MuiThemeProvider>

        <MyAppBar></MyAppBar>
        {this.props.children}
        
  
      </MuiThemeProvider>
    );
  } 







PAGINA LOGIN

Modificamos el componente Login.js

Incorporamos un nuevo componente de Material-ui. TexField para realizar los campos de mi formulario



Lo más significativo es como aplicamos los estilos

.formulario{

  height:100vh;
  width:100vw;
  display:flex;
  flex-direction:column;
  justify-content: center;
  align-items: center;
  background-size: cover;
  background-position: center;

}



Como establecemos una imagen de fondo:


IMAGEN DE FONDO EN UN DIV


Por otra parte es interesante como especificamos una imagen de fondo:

<div className = "formulario" style ={{'backgroundImage' : "url("+process.env.PUBLIC_URL + '/images/fondologin.jpeg'+")"}} >








COMPONENTES FUNCIONALES

Creamos un archivo Container.js


import React from 'react';


const Container = (props) => {

  return(


    <div className = "componenteFuncional">
      
      {props.children}

    </div>

  );

}

export default Container;



Vamos a ver la utilización en una página de prueba. Para ello vamos a crear un nuevo componente prueba que podemos utilizar en el futuro para esta clase de pruebas.



Prueba.js

import React from 'react';

import Container from '../components/Container' 

import Title from '../components/Title' 


export default class Prueba extends React.Component {

  render(){

    return (
      

      <Container>
        
        <p >Hola Mundo</p>
        <Title></Title>


      </Container>
    )
  }

}

Este componente funcional va a poder ser reutilizado en todo nuestro código.


Lo dejamos de momento como prueba conceptual.






PAGINA CREAR CUENTA

La página casi va a ser idéntica a nuestra página para realizar el login

Creamos el componente Signup. Lo integramos en nuestra aplicación de la manera habitual.


Hacemos uso en el componente Login y Signup de "Link"




RUTAS EN COMPONENTES

Vamos a reducir los dos componentes Login y Signup a uno solo mediante la utilización del Router

En el componente Login ya no solo llevamos a cabo la importación de Link

Llevamos a cabo la siguiente importación:

import {

  BrowserRouter as ReactRouter,
  Link,
  Route

} from 'react-router-dom';

El Router lo podemos utilizar en cualquier componente que nosotros queramos.


En nuestro componente Login

<ReactRouter>

  <div>

    <Route path="/login" exact render={()=>{

      return(

        <div >

          <RaisedButton label="Login" secondary={true} 
            style = {{"width" : "10vw", "marginTop" : "5em"}}
          />

          <Link to="/signup" style={{"textDecoration": "none", "marginLeft" : "2em", "color" : grey900}}>No tengo cuenta</Link>
      
        </div>
      )


    }}>
    
    </Route>

    <Route path="/signup" exact render={()=>{

      return(

        <div >

          <RaisedButton label="Registrarse" secondary={true} 
            style = {{"width" : "10vw", "marginTop" : "5em"}}
          />

          <Link to="/login" style={{"textDecoration": "none", "marginLeft" : "2em", "color" : grey900}}>Ya tengo cuenta</Link>
          

        </div>
      )


    }}>
    
    </Route>
  
  </div>

</ReactRouter>


En Router.js

................................

export default class Router extends React.Component {

  render(){

    return (

      <ReactRouter>

        <App>

          <Route exact path="/" component={Home}></Route>
                <Route path="/login" component={Login}></Route>
                <Route path="/signup" component={Login}></Route>
                <Route path="/prueba" component={Prueba}></Route>

          </App>
        
      </ReactRouter>

    )
  }

}


Todo sigue funcionando de la misma manera con un solo componente "Login"


Ponemsos el boton de Incio

Vemos que no se comporta de manera adecuada ya que tenemos dos instancias de ReactRouster

Una la tenemos en este componente y la otra instancia en Rouster.js

Eliminamos la de este fichero y funciona todo de manera correcta.

El ReactRouster solo tiene que aparecer una vez y luego podemos tener rutas donde nosotros queramos






RUTAS DINAMICAS

Hay a veces en que las rutas van a estar disponibles en función de una serie de condiciones

Por ejemplo una condición es que el usuario esté logueado.

Router.js

............................

const userLoggedIn = false;

export default class Router extends React.Component {

  authorizedRoutes(){

    if(userLoggedIn){

      return(

        <Route exact path="/prueba" component={Prueba}></Route>
      )
    }

  }

  render(){

    return (

      <ReactRouter>

        <App>

          <Route exact path="/" component={Home}></Route>
                <Route path="/login" component={Login}></Route>
                <Route path="/signup" component={Login}></Route>
                {this.authorizedRoutes()}

          </App>
        
      </ReactRouter>

    )
  }

}




Podemos también condicionar que componente va a responder a una petición dependiendo de una serie de condiciones

Definimos un componente Dashboard que va a ser el "home" para los usuarios que ya estén logueados

Hacemos algo de esta manera en Router.js

........................

const userLoggedIn = false;

export default class Router extends React.Component {

  authorizedRoutes(){

    if(userLoggedIn){

      return(

        <Route exact path="/prueba" component={Prueba}></Route>
      )
    }

  }

  home(){

    if (userLoggedIn) return Dashboard
    return Home
  }

  render(){

    return (

      <ReactRouter>

        <App>

          <Route exact path="/" component={this.home()}></Route>
                <Route path="/login" component={Login}></Route>
                <Route path="/signup" component={Login}></Route>
                {this.authorizedRoutes()}

          </App>
        
      </ReactRouter>

    )
  }

}





DASHBOARD PARA USUARIOS


Implementamos el componente Dashboard


La única novedad es la utlización de un icono para el botón de crear un nuevo negocio

import FloatingActionButton from 'material-ui/FloatingActionButton';
import ContentAdd from 'material-ui/svg-icons/content/add';
import ActionFlightTakeoff from 'material-ui/svg-icons/action/flight-takeoff';

<Link to="/new" >

  <FloatingActionButton secondary = {true} className = "boton-new" >
    <ContentAdd />
  </FloatingActionButton>


</Link>





COMPONENTE ESPECIFICO PARA MOSTRAR LOS NEGOCIOS EN DASHBOARD

Realizamos un componente especifico para la vista de Dashboard

PlaceCardDashboard.js 






TRANSICIONES EN LAS PAGINAS


Switch del Router

Router.js

import React from 'react';

import {

  BrowserRouter as ReactRouter,
  Route,
  Switch

} from 'react-router-dom';

.............................


render(){

    return (

      <ReactRouter>

        <App>

          <Switch>
            <Route exact path="/" component={this.home()}></Route>
            <Route path="/login" component={Login}></Route>
            <Route path="/signup" component={Login}></Route>
            {this.authorizedRoutes()}
            
          </Switch>

          

          </App>
        
      </ReactRouter>

    )
  }


Definir Animación CSS

.left-out-enter {
  opacity: 0;
  transform: translateX(100%);
}

.left-out-enter-active {
  opacity: 1;
  transform: translateX(0);
}

.left-out-exit {
  opacity: 1;
  transform: translateX(100%);
}

.left-out-exit-active {
  opacity: 0;
  transform: translateX(0);
}



Componentes de la animación con el Router


App.js


import React, { Component } from 'react';
import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';

import CSSTransition from 'react-transition-group/CSSTransition'
import TransitionGroup from 'react-transition-group/TransitionGroup'

.........

render() {
    
    return (

      <MuiThemeProvider>

        <MyAppBar></MyAppBar>

        <TransitionGroup>
          
          <CSSTransition classNames="left-out" timeout = {300}>
            
            {this.props.children}  
          
          </CSSTransition>
          
          

        </TransitionGroup>
        
        
  
      </MuiThemeProvider>
    );
  }


Nos falta agregar el prop key que es importante para que la transición se produzca

Necesitamos un valor que se actualice cada vez que modifiquemos la página.


Vamos a llevar a cabo la importación de un objeto withRouter como parte del react-router-dom

Este objeto inserta en props información que está relacionada con las rutas


App.js

import { withRouter } from 'react-router-dom'

.......

export default withRouter(App);

Esta sintáxis es lo mismo que si hicieramos algo de esta manera

App = withRouter(App)
export default App;



Agregamos el prop key de la siguiente manera:

<CSSTransition classNames="left-out" timeout = {300} 

key= {this.props.location.pathname.split('/')[1]}>
            
            {this.props.children}  
          
</CSSTransition>


Si queremos ver el prop que ha sido insertado lo podemos hacer haciendo un console.log(props) en el constructor


En location tenemos lo que nos interesa:

location:
  hash:""
  pathname:"/"
  search:""
  state:undefined


En principio no funciona con la versión 16 de React. parece que es un bug. Funcionaría con la 15 pero lo dejamos en la 16





Vamos a entrar en la parte más interesante del proyecto. Consumir un servicio WEB realizado por nosotros mismos en Node.js

Lo podemos clonar de mi git. Concretamente es el proyecto Node.js-Web-Service


Para poder trabajar de momento con el mismo podemos realizar las siguientes modificaciones:

Hacemos que escuche en 3001

Abrimos fichero bin/www

var port = normalizePort(process.env.PORT || '3001');


En app.js comentamos la siguiente línea:

app.use(authApp.unless({method:'OPTIONS'}))




API Fetch. DESCARGAR NEGOCIOS DEL SERVIDOR WEB


Primero vamos a modificar nuestro servicio web para que en nuestro servidor de ficheros estáticos esté incluido el directorio uploads

app.use(express.static(path.join(__dirname, 'uploads')));


Modificamos requests/places de la siguiente manera:

function getPlaces(){

  return fetch("http://127.0.0.1:3001/places")

    .then((response)=>{

      return response.json()
    })

    .catch((error)=>{

      console.log(error)
    })
}

export {getPlaces}


Modificamos así mismo varios ficheros en aplicación para que se  adequen a las  nuevas modificaciones.

El JSON que se recibe es de la siguiente forma:

{
  "docs": [
    {
      "acceptsCreditCard": true,
      "_id": "5aa662eea464cd21f0df606b",
      "title": "Primera Empresa",
      "description": "Primera Empresa en la base de datos",
      "coverImage": "uploads\\25244a94437262b5be8f0731ae04c101",
      "avatarImage": "uploads\\9a7bb8aafa7e40b47e17b1776765dad5",
      "openHour": 9,
      "closeHour": 23,
      "_user": "5a7b2acca6ba480854467e8d",
      "slug": "primera-empresa",
      "__v": 0
    },

    ............................





INFORMACIÓN INDIVIDUAL DE UN NEGOCIO


Añadimos la siguiente ruta:

<Route path="/lugares/:slug" component={Place}></Route>


Creamos ese componente nuevo:

Place.js


Configuramos los botones de "Ver mas......." de la siguiente manera

<CardActions style={{"textAlign": "left"}}>

  <Link to={"/lugares/" + this.props.place.slug}>

    <FlatButton label="Ver mas....." secondary={true}/>

  </Link>
  
  
  
</CardActions>

Conseguimos urls de la siguiente manera:

http://127.0.0.1:3000/lugares/primera-empresa


Es obhvio que necesitamos el slug para poder realizar la consulta. Tenemos que ser capaces de alguna manera de acceder a la URL


Esto ya lo realizamos anteriormente con withRouter

Si realizamos un console.log(props) seremos capaces de saber que el parametro que estamos buscando es 

props.match.params.slug


Una vez que tenemos el slug tenemos que ser capaces de a través de este slug retornar el json en el que estamos interesados.


Añadimos la función getPlace de la siguiente manera:



function getPlace(slug){

  return fetch("http://127.0.0.1:3001/places/" + slug)

    .then((response)=>{

      return response.json()
    })

    .catch((error)=>{

      console.log(error)
    })
}

export {getPlaces, getPlace}


Finalmente en Place.js implementamos lo necesario para acceder a los parámetros de mi lugar



DESTRUCTURING ASSIGNMENT ES6

Nos permite hacer algo de la siguiente manera:

render(){

  const {place} = this.state
  
  return(

    .......................

    place.avatarImage

  )
}


De momento no lo aplicamos y dejamos el código como está



LINK HACIA HOME EN APPBAR

Creamos la siguiente función en App.js

goHome(){

    this.props.history.push('/')
}

De esta manera tenemos acceso a los props que inserta withRouter

Realizamos el bind para que no pierda el contexto y se la pasamos como un prop a nuestro componente de la barra.


Este componente tiene un prop


import React from 'react';

import AppBar from 'material-ui/AppBar';

export default class MyAppBar extends React.Component {

  render(){

    return (

      <AppBar
          title="Places"

          style ={{"backgroundColor" : "#000" }}

          showMenuIconButton = {false}

          titleStyle ={{"color" : "#F5F5F5"}}

          onTitleClick={this.props.goHome}
          
      />

    )
  }

}


Uno de los aspectos que hay que comprender muy bien es el paso de funciones entre componentes como props.






INICIAR SESION Y CREAR CUENTA

Agregamos un ref a nuestros elementos para acceder de manera rápida a sus valores en el DOM

Creamos 2 funciones una para realizar el login y la otra para crear los usuarios



import { login, signUp } from '../requests/auth'


export default class Login extends React.Component {

  constructor(props){

    super(props)

    this.requestAuth = this.requestAuth.bind(this)

    this.createAccount = this.createAccount.bind(this)

  }

  requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      console.log(response)
    
    }).catch((error)=>{

      console.log(error)
    })

  }

  createAccount(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }


    signUp(credentials).then((response)=>{

      console.log(response)
    
    }).catch((error)=>{

      console.log(error)
    })

  }


  render(){

  .................................................

  .................................................


  Implementamos requests/auth

  function login(credentials){

  return fetch("http://127.0.0.1:3001/sessions",{

    method: 'POST',
    body: JSON.stringify(credentials),
    headers:{
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    }
  }).then((response)=>{

      return response.json()
  
  }).catch((error)=>{

    console.log(error)
  })
}

function signUp(credentials){

  return fetch("http://127.0.0.1:3001/users",{

    method: 'POST',
    body: JSON.stringify(credentials),
    headers:{
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    }
  }).then((response)=>{

      return response.json()
  
  }).catch((error)=>{

    console.log(error)
  })
}

export {login,signUp}


¿ Donde almacenamos el jwt ?

Vamos a usar un almacenamiento central para todos los componentes.

Una de las arquitecturas más usadas es REDUX





FUNDAMENTOS REDUX


Librería que nos permite controlar el estado de nuestra aplicación.


Source of Truth(Fuente de la Verdad)

Uno de los principales componentes de la arquitectura. Es donde toda la información se concentra.




Inmutabilidad

Estado de un objeto lo podríamos definir como el valor actual de todas sus propiedades.

Concepto de inmutabilidad tiene que ver con que si quieres cambiar algo de el objeto, lo tienes que reemplazar por otro objeto. No puedes modificar sus partes....tienes que sustituir el objeto por completo.



INSTALAR Y CONFIGURAR REDUX Y REACT REDUX


Instalamos las librerías necesarias

npm install redux --save

npm install react-redux --save


Vamos a crear el store que es donde se alamacena el estado de nuestra aplicación

Creamos una carpeta llamada store

Creamos el archivo configureStore.js que se va a encargar de configurar el almacenamiento


createStore recibe dos argumentos. El primero de ellos es el reducer a traves del cual se van a manipular el estado del contenedor

El reducer es una función pura que recibe el estado, la acción que tiene que realizar y retorna un nuevo estado.

Por ahora solo pasamos una función con el estado original, una acción y retornamos el estado


Se puede establecer un segundo argumento. 


Una vez que tenemos esto se puede exportar el almacenamiento.


En el siguiente apartado vamos a crear nuestro verdadero reducer. Vamos a hacerlo de una manera en que podamos dividir el manejo de nuestro almacenamiento en diferentes reducers y no todo tenga que pasar por una sola funcion.






CONFIGURAR REDUCERS

Podremos variar el estado de nuestra aplicación a través de Reducers

Creamos la carpeta reducers

Creamos dentro de la carpeta 2 archivos index.js y placesReducer.js

placesReducer.js

Función o reducer que se va a encargar de manipular las acciones  que tengan que ver con los negocios de nuestra aplicación:


export default function placesReducer(state = [] , action ){

  return state

}


index.js

Integramos diferentes reducers en un sólo reducer para pasarselo a createStore para que se genere nuestro almacenamiento



import places from './placesReducer'

export default {places: places}




configureStore.js


import {createStore, combineReducers} from 'redux'

import reducers from '../reducers'

const rootReducer = combineReducers({

  ...reducers
})

export default function configureStore(){

  return createStore(rootReducer)

}


En la constante rootReducer tenemos combinados todos nuestros reducers.
Esto posteriormente se lo pasamos a la funcion createStore



Vamos a construir finalmente nuestro store de la siguiente manera.

Nos vamos a index.js que es nuestro archivo de entrada para toda la aplicación.

Importamos configureStore que es una función que al ejecutarla genera finalmente nuestro almacenamiento.

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import Router from './Router';
import registerServiceWorker from './registerServiceWorker';

import configureStore from './store/configureStore'

const store = configureStore();

ReactDOM.render(<Router />, document.getElementById('root'));
registerServiceWorker();




PROVIDER COMPONENT EN REACT-REDUX

Para poder manipular el almacenamiento dentro de los componentes de nuestra aplicación tenemos que tener acceso a este almacenamiento

Una manera de hacerlo podría ser pasar el almacenamiento como un prop para todos nuestros componentes. Tedioso y poco operativo.

Otra manera de hacerlo es mediante el "Provider" que viene con react-redux

En index.js (Entrada a nuestra aplicación)

Al componente "Provider" le vamos a pasar como prop nuestro almacenamiento.

Y de esta manera todos nuestros componentes van a tener acceso al almacenamiento.


index.js queda de la siguiente manera:

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import Router from './Router';
import registerServiceWorker from './registerServiceWorker';

import configureStore from './store/configureStore'

import { Provider } from 'react-redux'

const store = configureStore();

ReactDOM.render(

  <Provider store={store}><Router /></Provider>
  , document.getElementById('root'));
registerServiceWorker();





CREAR ACCIONES

La única manera en que podemos mutar el estado del contenedor es a través de acciones

Acciones son objetos que tiene una propiedad "type" donde se indica que acción se tiene que ejecutar sobre el contenedor que después pasan a los reducers y estos basados en el tipo de acción saben que modificación tienen que llevar a cabo.


Creamos una nueva carpeta en src llamada actions

Creamos un nuevo archivo placesActions.js donde vamos a crear las acciones que van a modificar el state en la parte de los negocios.


Creamos la siguiente acción:

export function loadPlaces(places){

  return { type: 'LOAD_PLACES', places:places}
}

Una vez que tenemos nuestra accion, vamos a configurar nuetro reducer


placesReducer.js

export default function placesReducer(state = [] , action ){

  switch (action.type){
    
    case 'LOAD_PLACES':

      return action.places

    default: 

      return state
  }

}




RESUMEN:


Reducer es una funcion pura que recibe el estado y la accion que tiene que realizar y retorna un nuevo estado

El estado solo se puede modificar a través de los reducers


En index.js dentro de la carpeta reducers vamos a integrar diferentes reducers en uno solo para posteriormente pasarselo a createStore y que se genere nuestro almacenamiento.






CONVERTIR HOME EN CONTAINER COMPONENT


Vamos a trabajar en nuestro componente Home

No es recomendable que todos los componentes interactuen con el contenedor.

Para convertir este componente en un contenedor que pueda interactuar con el almacenamiento lo primero que tenemos que realizar es la importación de una función connect

import { connect } from 'react-redux'

Después vamos a requerir que la clase que estamos exportando pase por esa función connect de la siguiente manera:

"connect" recibe una función que traduce como esta estructurado nuestro estado a props que después se van a enviar al componente.




function mapStateToProps(state,ownProps){

  return {

    places: state.places
  }
}

export default connect(mapStateToProps)(Home)


La función recibe dos argumentos. Recibe el state y los props del componente.

Retorna un JSON que especifica que en el prop places coloque lo que hay en la  propiedad places del contenedor.

En esta propiedad places llega todo lo que se modifica en los reducers.


A partir de este momento nuestro componente Home se convierte en un Container Component. 


Para corroborar que en este prop places se encuentra lo que el contenedor tiene en la propiedad places del state, realizamos lo siguiente.

...................................

...................................

class Home extends React.Component {

  constructor(props){

      super(props)

      this.state = {

        places:[]
      
      }

      console.log(this.props.places)

      this.loadPlaces()

      this.hidePlace = this.hidePlace.bind(this)

  }

Si observamos en la consola nos aparece un arreglo vacío que si nos vamos al reducer vemos que el state por defecto para places es un arreglo vacío

export default function placesReducer(state = [] , action ){

  switch (action.type){
    
    case 'LOAD_PLACES':

      return action.places

    default: 

      return state
  }

}

Si variamos su estado por defecto. Por ejemplo:

export default function placesReducer(state = [1] , action ){

  switch (action.type){
    
    case 'LOAD_PLACES':

      return action.places

    default: 

      return state
  }

}

Podemos comprobar que en consola aparece [1]

Observamos que realmente se nos está inyectando como parte de nuestros props

Por lo tanto ya tenemos sincronizado en este componente información de nuestro container




GUARDAR TOKEN EN EL STATE

Hacemos todo el flujo para guardar token en state y tener datos sincronizados

Creamos un nuevo reducer. userReducer.js

export default function userReducer(state = {} , action ){

  switch (action.type){
    
    case 'LOG_IN':

      return {jwt: action.jwt}

    default: 

      return state
  }

}


Creamos userActions.js

export function login(jwt){

  return { type: 'LOG_IN', jwt}
}


Convertimos Login en un Container Component


............

import { connect } from 'react-redux'

-------------

class Login extends React.Component {

--------------

}


function mapStateToProps(state,ownProps){

  return {

    user: state.user
  }
}

export default connect(mapStateToProps)(Login)


index.js en carpeta reducers


import places from './placesReducer'

import user from './userReducer'

export default {places: places, user:user}


Corroboramos que lo estamos haciendo de manera correcta:


Al igual que hemos hecho antes en Home en el constructor 

console.log(this.props.user)

y en el reducer 

export default function userReducer(state = {name : 'Prueba'} , action ){

  switch (action.type){
    
    case 'LOG_IN':

      return {jwt: action.jwt}

    default: 

      return state
  }

}

Nos vamos a la página de Login y vemos que hemos realizado todos los pasos de manera correcta.



Hasta ahora al hacer login teníamos lo siguiente:

requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      console.log(response)
    
    }).catch((error)=>{

      console.log(error)
    })

  }

En la respuesta que se manda nos interesa el jwt


Como enviamos estos cambios hacia el contenedor central

La única forma es realizando un dispatch de una acción


Primero tenemos que importar los actions del user


Lo hacemos de la siguiente manera:

import * as actions from '../actions/userActions'


Esto quiere decir que importamos todo lo que estamos exportando y lo pone en un objeto con el nombre actions



Finalmente:

requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      //console.log(response)

      this.props.dispatch(actions.login(response.jwt))
    
    }).catch((error)=>{

      console.log(error)
    })

  }


Para comprobar que se realiza de manera correcta:

Encima de los campos de los formualarios lo imprimimos

<h1>{this.props.user.jwt}</h1>


Funciona correctamente. 


Inconveniente es que cuando se recarga la página esa información desaparece.

En la mayoría de los casos es correcto que funcione de esta manera.

Pero en este caso es necesario que perdure......para ello vamos a utilizar el LocalStorage






PERSISTENCIA CON LOCALSTORAGE

Para poder persistir ciertos datos aunque el usuario recarge la página vamos a hecer uso de LocalStorage

Instalamos 

npm install redux-localstorage

Nos vamos a configureStore.js


import persistState from 'redux-localstorage'

Básicamente va a ser un potenciador. Va a potenciar las capacidades de nuestro almacenamiento



Vamos a importar también 'compose'

import {createStore, combineReducers, compose} from 'redux'


Es una función que está diseñada cuando queremos aplicar los potenciadores en fila

const enhancer = compose(

  persistState('user')

)

Se genera una función que va a ser nuestro enhancer final..

Cada función que colocamos tiene como parámetro la salida de la función anterior

El resultado de una función se utiliza como argumento de la siguiente función.



Podríamos hacer algo de la siguiente manera:

const enhancer = compose(

  persistState('user'),
  otroPotenciador()

)

En nuestro caso solo tenemos una función.


El enhancer final lo pasamos como tercer argumento a nuestra función createStore

El segundo argumento es el valor inicial de nuestro contenedor

Nos queda todo de la siguiente manera:



import {createStore, combineReducers, compose} from 'redux'

import persistState from 'redux-localstorage'

import reducers from '../reducers'

const enhancer = compose(

  persistState('user')

)

const rootReducer = combineReducers({

  ...reducers
})

export default function configureStore(){

  return createStore(rootReducer,{},enhancer)
}

Observamos que al recargar la página ya no desaparece. Está persistiendo que es lo que queremos.

Vamos a convertir el Router en un Container Component

Lo hacemos de la manera habitual



Una vez que hemos hecho esto ya tenemos acceso desde este componente Router a this.props.user.jwt


Podemsos utilizar este valor en vez de la constante que usabamos para simular que el usuario estaba logueado.

Si no es null, falso o undefined nos hace perfectamente la funcionalidad


Vemos que nos lleva a Dashboard de manera correcta.

Si fijamos el valor a null en el reducer

export default function userReducer(state = {} , action ){

  switch (action.type){
    
    case 'LOG_IN':

      return {jwt: null}

    default: 

      return state
  }

}

Esta vez cuando nos vamos a http://127.0.0.1:3000/ nos muestra el Home


Tenemos que observar que cuando realizamos el login, no nos lleva automáticamente al Dashboard


Necesitamos integrar redux con nuestro Router.

Antes de realizar esto llevamos a cabo una purga de errores en consola. No todos







INSTALAR Y CONFIGURAR REACT-ROUTER-REDUX

Instalamos de la siguiente manera:

npm install react-router-redux@next --save

Necesitamos la versión 5

"react-router-redux": "^5.0.0-alpha.9"

Ya que estamos trabajando con la versión 4 del router y esta es la versión que necesitamos para poder trabajar con esta versión.

"react-router-dom": "^4.2.2"


También instalamos la dependencia history

npm install history --save

Vamos a trabajar en el Router por un lado y en el configureStore por otro 

configureStore.js

import {routerReducer} from 'react-router-redux'

Lo pasamos a la función que está combinando el resto de nuestros reducers de la siguiente manera:

const rootReducer = combineReducers({

  ...reducers,
  router: routerReducer
})

Especificamos que en la función configureStore puedo recibir un argumento middleware

Ese middleware lo voy a utlizar como segundo argumento de la función createStore

Mandamos llamar a la función applyMiddleware, ahora veremos de donde sale con el argumento middleware

Nos queda de la siguiente manera:

export default function configureStore(middleware){

  return createStore(
    rootReducer,
    applyMiddleware(middleware),
    enhancer)
}

Tenemos por lo tanto 3 actores en la configuración del almacenamiento del state

Tenemos los reducers, los middlewares que son acciones que se procesan en medio de la petición de procesar algo en el store y los potenciadores.


De donde sale ese middleware. Nos vamos al Router.

Router.js

LLevamos a cabo la siguiente importación

import { ConnectedRouter} from 'react-router-redux'


Sustituimos el ReactRouter por este ConnectedRouter

A este ConnectedRouter le pasamos un prop history con el historial

......................

render(){

    return (

      <ConnectedRouter history={this.props.history}>

        <App>

          <Switch>
            <Route exact path="/" component={this.home()}></Route>
            <Route path="/lugares/:slug" component={Place}></Route>
                <Route path="/login" component={Login}></Route>
                <Route path="/signup" component={Login}></Route>
                {this.authorizedRoutes()}

          </Switch>

          

          </App>
        
      </ConnectedRouter>

    )
}


Por último para terminar nuestra configuración tenemos que ir a index.js

index.js

import createHistory from 'history/createBrowserHistory'
import { routerMiddleware } from 'react-router-redux'


Creamos una nueva constante que es el history

const history = createHistory()

Creamos la constante middleware

const middleware = routerMiddleware(history)

Ese middleware lo pasamos a configureStore de la siguiente manera:

const store = configureStore(middleware);


Recordar que ConnectedRouter está esperando un prop llamado history que es el que generamos más arriba


Si corremos npm start nos alerta que la función applyMiddleware no está definida

La tenemos que importar de  'redux' en configureStore.js


Observamos que despusés de todo esta configuración todo sigue funcionando correctamente


Resumen de los ficheros:

configureStore.js

import {createStore, combineReducers, compose, applyMiddleware} from 'redux'

import persistState from 'redux-localstorage'

import reducers from '../reducers'

import {routerReducer} from 'react-router-redux'

const enhancer = compose(

  persistState('user')

)

const rootReducer = combineReducers({

  ...reducers,
  router: routerReducer
})

export default function configureStore(middleware){

  return createStore(
    rootReducer,
    applyMiddleware(middleware),
    enhancer)
}


index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import Router from './Router';
import registerServiceWorker from './registerServiceWorker';

import configureStore from './store/configureStore'

import { Provider } from 'react-redux'

import createHistory  from 'history/createBrowserHistory'

import { routerMiddleware } from 'react-router-redux'

const history = createHistory()

const middleware = routerMiddleware(history)

const store = configureStore(middleware);

ReactDOM.render(

  <Provider store={store}><Router history = {history} /></Provider>
  , document.getElementById('root'));
registerServiceWorker();


Router.js

LLevamos a cabo la siguiente importación

import { ConnectedRouter} from 'react-router-redux'


Sustituimos el ReactRouter por este ConnectedRouter

A este ConnectedRouter le pasamos un prop history con el historial






DISPATCH DE ACCIONES DE NAVEGACION

Queremos que despues de realizar la autenticación podamos realizar un redireccionamiento

Nos vamos a Login

import { push } from 'react-router-redux'

.........

requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      //console.log(response)

      this.props.dispatch(actions.login(response.jwt))

      this.props.dispatch(push('/'))
    
    }).catch((error)=>{

      console.log(error)
    })

}

Ejecutamos la función push que la importamos de 'react-router-redux'

Es un action creator de react-router-redux. Genera una acción con el type y la información necesaria para que el routerReducer se encarge de llevar a cabo el cambio en la navegación.

Vemos que ahora somos capaces de realizar dispatch de acciones que se traduzcan en modificaciones en la navegación.





MODIFICACIÓN BARRA DE NAVEGACION. INTEGRACIÓN CON REDUX. CONTAINER COMPONENT


Nuestra barra de navegación (AppBar) es un componente de presentación

No sería aconsejable en un componente de presentación llevar a cabo la anterior integración.

Para ello vamos a realizar un nuevo componente que va a ser un Container Component en el que vamos a realizar la integración con Redux

Este nuevo componente contenedor contendrá a AppBar y será en este nuevo componente donde realicemos la integración con Redux

Creamos un nuevo componente al que vamos a llamar Navigation que va a ser un Container Component



import React from 'react'

import MyAppBar from './MyAppBar'

import { connect } from 'react-redux'

import { push } from 'react-router-redux'

class Navigation extends React.Component {

  constructor(props){

    super(props)

    this.goHome = this.goHome.bind(this)
  }

  goHome(){

      this.props.dispatch(push('/'))
    }



  render(){

    return(

      <MyAppBar goHome = {this.goHome}></MyAppBar>

    )
  }
}



function mapStateToProps(state,ownProps){

  return {

    user: state.user
  }
}

export default connect(mapStateToProps)(Navigation)





ALMACENAR INFORMACION DEL USUARIO. DISPLAY EN APPBAR


Cuando realizamos login se nos devuelve la siguiente información en 


requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      console.log(response)

      this.props.dispatch(actions.login(response.jwt))

      this.props.dispatch(push('/'))
    
    }).catch((error)=>{

      console.log(error)
    })

}


En response.jwt tenemos el token

En response.user tenemos la información del usuario


Creamos en userActions.js un nuevo action creator de la siguiente manera:

export function login(jwt){

  return { type: 'LOG_IN', jwt}
}

export function loadUser(user){

  return { type: 'LOAD_USER', user}
}


Posteriormente nos vamos a userReducers.js


Hasta ahora realizabamos lo siguiente:

case 'LOG_IN':

      return {jwt: action.jwt}

Esto puede traducirse en bugs y malfuncionamiento.

Lo hacemmos de manera correcta:

Clonaremos el state original, agregarle la modificación y retornarlo


Javascript posee Object.assign() que recibe tres argumentos.

El primer argumento es un objeto al cual se va a asignar el nuevo objeto creado

Como segundo argumento un objeto del cual queremos pasar todas las propiedades al nuevo objeto.

Tercer argumento opcional que lo que va a hacer es agregar o modificar las propiedades del objeto que estamos clonando


Object.assign({},state,{jwt:action.jwt})

Nos queda de la siguiente manera:

case 'LOG_IN':

      return Object.assign({},state,{jwt:action.jwt})



export default function userReducer(state = {} , action ){

  switch (action.type){
    
    case 'LOG_IN':

      return Object.assign({},state,{jwt:action.jwt})

    case 'LOAD_USER':

      return Object.assign({},state,{

        name: action.user.name,
        _id: action.user._id,
        email: action.user.email
      })

    default: 

      return state
  }

}


Una vez que hemos realizado esto vamos a hacer uso de esa información


Tenemos que irnos primero a nuestro Login.js

Añadimos la siguiente línea:

requestAuth(){

    const credentials = {

      email : this.refs.emailField.getValue(),
      password : this.refs.passwordField.getValue()
    
    }

    login(credentials).then((response)=>{

      //console.log(response)

      this.props.dispatch(actions.login(response.jwt))

      this.props.dispatch(actions.loadUser(response.user))

      this.props.dispatch(push('/'))
    
    }).catch((error)=>{

      console.log(error)
    })

}

Ahora ya nos podemos ir a Navigation que es un Contenedor que está conectando con nuestro storage


Le pasamos a nuestro MyAppBar el user como un prop


<MyAppBar goHome = {this.goHome} user = {this.props.user}></MyAppBar>


Finalmente nos vamos a nuestro componente de Presentación MyAppBar

Vamos a jugar con la información que le estamos pasando:


Nos queda de la siguiente manera:

import React from 'react';

import AppBar from 'material-ui/AppBar';

export default class MyAppBar extends React.Component {

  

  setTitle(){

    if (this.props.user.jwt){

      return "Bienvenido " + this.getName()
    
    }else{

      return "PLACES"
    }
  }

  getName(){

    return this.props.user.email.split('@')[0]
  }


  render(){

    return (

      <AppBar
          
          title= {this.setTitle()}

          style ={{"backgroundColor" : "#000" }}

          showMenuIconButton = {false}

          titleStyle ={{"color" : "#F5F5F5", "cursor":"pointer", "textTransform": "capitalize"}}

          onTitleClick={this.props.goHome}
          
      />

    )
  }

}







CERRAR SESION

Creamos 2 nuevos componentes que vamos a integrar en MyAppBar.js

LoginButton y LogoutButton

Los creamos, los importamos y los integramos de la siguiente manera:

iconElementRight={this.props.user.jwt ? <LogoutButton logout = {this.props.logout} /> : <LoginButton/>}


Al botón le pasamos en un prop una función logout

A su vez esta función es un prop que hemos pasado desde Navigation que es nuestro Container Component

El botón me queda de la siguiente manera:

import React from 'react'

import FlatButton from 'material-ui/FlatButton';

export default class LogoutButton extends React.Component{

  render(){

    return(


      <FlatButton  label="Logout" 
            style ={{"backgroundColor" : "#000", "color" : "#F5F5F5" }}
            onClick = {this.props.logout}

             />
    )
  }
}

En Navigation por lo tanto vamos a tener la siguiente función:

logout(){

  this.props.dispatch(logout())

  this.props.dispatch(push('/'))
}

Le pasamos a MyAppBar la funcion de la siguiente manera:

<MyAppBar goHome = {this.goHome} user = {this.props.user} logout = {this.logout}></MyAppBar>


Ahora tenemos que configurar esta parte para que se produzca el logout

userActions queda de la siguiente manera:

export function login(jwt){

  return { type: 'LOG_IN', jwt}
}

export function loadUser(user){

  //console.log(user)

  return { type: 'LOAD_USER', user}
}

export function logout(){

  return { type: 'LOG_OUT'}
}


userReducers queda de la siguiente manera:

export default function userReducer(state = {} , action ){

  switch (action.type){
    
    case 'LOG_IN':

      return Object.assign({},state,{jwt:action.jwt})

    case 'LOG_OUT':

      return {}

    case 'LOAD_USER':

      return Object.assign({},state,{

        name: action.user.name,
        _id: action.user._id,
        email: action.user.email
      })

    default: 

      return state
  }

}

Básicamente retornamos un objeto vacío


En Navigation importante la siguiente línea:

import { logout } from '../actions/userActions'


Para el botón de Login nos queda de uana manera bastante sencilla:

import React from 'react'

import FlatButton from 'material-ui/FlatButton';

import {Link} from 'react-router-dom'

export default class LoginButton extends React.Component{

  render(){

    return(

      <Link to="/login">

        <FlatButton  label="Login" 
              style ={{"backgroundColor" : "#000", "color" : "#F5F5F5" }} />
        

      </Link>


      
    )
  }
}







MENU DESPLEGABLE PARA LOGOUT. ICON MENU

Vamos a cambiar el botón de cerrar sesión por un menu que desplegue más de una opción.

Vamos a utilizar un Icon Menu de Material Design


Único que vamos a hacer notar es como damos estilo al Icon de la siguiente manera:

iconButtonElement={<IconButton iconStyle={{"fill":"white"}}><MoreVertIcon /></IconButton>}


Componente queda de la siguiente manera:

import React from 'react'

import IconMenu from 'material-ui/IconMenu';
import MenuItem from 'material-ui/MenuItem';
import IconButton from 'material-ui/IconButton';
import MoreVertIcon from 'material-ui/svg-icons/navigation/more-vert';

export default class LogoutButton extends React.Component{

  render(){

    return(
      
      <IconMenu
           iconButtonElement={<IconButton iconStyle={{"fill":"white"}}><MoreVertIcon /></IconButton>}
             anchorOrigin={{horizontal: 'left', vertical: 'top'}}
             targetOrigin={{horizontal: 'left', vertical: 'top'}}
        >
            <MenuItem primaryText="LOGOUT" onClick = {this.props.logout}/>
            
        </IconMenu>
    )
  }
}




FINALIZACION CREAR CUENTAS DE USUARIO

Cuando creamos  el usuario vamos a especificar en un campo el nombre del usuario.

Dado que en la estructura que tenemos ahora para 'login y logout' utilizamos el mismo componente Login y esto va a provocar problemas con los refs........

Vamos a volver a una situación donde creamos un componente para el login y otro para el logout


Primero por lo tanto llevamos a cabo la separación de ambos y que todo funciones como antes:


En componente Signup agregamos un nuevo campo para que en el registro del usuario se lleve a cabo la configuración del nombre del usuario


Una vez que ya estamos creando nuesvos usuarios con un nombre...vamos a sacar este en la AppBar



